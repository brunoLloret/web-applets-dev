var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AppletContext_actions, _AppletContext_data;
import { AppletMessage, AppletDataEvent, AppletLoadEvent, AppletReadyEvent, AppletActionsMessage, AppletReadyMessage, AppletMessageRelay, } from './shared';
export class AppletContext extends EventTarget {
    constructor() {
        super();
        this.actionHandlers = {};
        _AppletContext_actions.set(this, {});
        _AppletContext_data.set(this, void 0);
        this.connect();
    }
    connect() {
        this.messageRelay = new AppletMessageRelay(window.parent);
        // When document loads/if it's loaded, call the initialize function
        if (document.readyState === 'complete' ||
            document.readyState === 'interactive') {
            // Document has loaded already.
            // Timeout added so if the caller defines the onload function, it will exist by now
            setTimeout(this.initialize.bind(this), 1);
        }
        else {
            // Document not yet loaded, we'll add an event listener to call when it does
            window.addEventListener('DOMContentLoaded', this.initialize.bind(this));
        }
        this.createResizeObserver();
        this.attachListeners();
    }
    async initialize() {
        const manifestLinkElem = document.querySelector('link[rel="manifest"]');
        if (!manifestLinkElem)
            return;
        try {
            const manifestRequest = await fetch(manifestLinkElem.href);
            const manifest = await manifestRequest.json();
            this.manifest = manifest;
            this.actions = manifest.actions ?? [];
        }
        catch (e) {
            return;
        }
        // Call the onload function
        const loadEvent = new AppletLoadEvent();
        this.dispatchEvent(loadEvent);
        if (typeof this.onload === 'function')
            await this.onload(loadEvent);
        // Tell the host we're ready
        this.messageRelay.send(new AppletReadyMessage());
        // Emit a local ready event
        const readyEvent = new AppletReadyEvent();
        this.dispatchEvent(readyEvent);
        if (typeof this.onready === 'function')
            this.onready(readyEvent);
    }
    createResizeObserver() {
        const resizeObserver = new ResizeObserver((entries) => {
            for (let entry of entries) {
                const message = new AppletMessage('resize', {
                    dimensions: {
                        width: entry.contentRect.width,
                        height: entry.contentRect.height,
                    },
                });
                this.messageRelay.send(message);
            }
        });
        resizeObserver.observe(document.querySelector('html'));
    }
    attachListeners() {
        this.messageRelay.on('init', (message) => {
            this.manifest = message.manifest;
            this.actions = this.manifest?.actions || [];
        });
        this.messageRelay.on('data', (message) => {
            this.setData(message.data);
        });
        this.messageRelay.on('action', async (message) => {
            if (Object.keys(this.actionHandlers).includes(message.actionId)) {
                await this.actionHandlers[message.actionId](message.params);
            }
        });
    }
    setActionHandler(actionId, handler) {
        this.actionHandlers[actionId] = handler;
    }
    defineAction(actionId, definition) {
        const { handler, ...properties } = definition;
        this.actions = [
            ...this.actions,
            {
                id: actionId,
                ...properties,
            },
        ];
        this.setActionHandler(actionId, handler);
    }
    set actions(actions) {
        if (!actions)
            return;
        for (let action of actions) {
            __classPrivateFieldGet(this, _AppletContext_actions, "f")[action.id] = action;
        }
        this.messageRelay.send(new AppletActionsMessage({ actions: this.actions }));
    }
    get actions() {
        return Object.values(__classPrivateFieldGet(this, _AppletContext_actions, "f"));
    }
    set data(data) {
        this.setData(data);
    }
    get data() {
        return __classPrivateFieldGet(this, _AppletContext_data, "f");
    }
    async setData(data) {
        const dataMessage = new AppletMessage('data', { data });
        await this.messageRelay.send(dataMessage);
        __classPrivateFieldSet(this, _AppletContext_data, data, "f");
        const dataEvent = new AppletDataEvent({ data });
        this.dispatchEvent(dataEvent);
        this.ondata(dataEvent);
    }
    onload(event) { }
    onready(event) { }
    ondata(event) { }
}
_AppletContext_actions = new WeakMap(), _AppletContext_data = new WeakMap();
export function getContext() {
    return new AppletContext();
}
